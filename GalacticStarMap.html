<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Galactic Starmap</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Inter', sans-serif;
            color: #ffffff;
        }
        canvas {
            display: block;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            transition: opacity 1s ease-out;
        }
        #loading-screen.fade-out {
            opacity: 0;
        }
        #loading-text {
            font-size: 1.5rem;
            color: #00aaff;
            text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        .label {
            color: #fff;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            pointer-events: none; /* Important so clicks pass through to the canvas */
            font-size: 14px;
        }
        .region-label {
            color: #ffc107;
            font-weight: bold;
            text-shadow: 0 0 5px #ffc107, 0 0 10px #ffc107;
            pointer-events: none;
            transition: font-size 0.1s ease-out; /* Smooth scaling */
        }
        #modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background-color: rgba(10, 25, 47, 0.9);
            border: 1px solid #38bdf8;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
            display: none;
            z-index: 100;
            color: #e0f2fe;
        }
        #modal-content h2 {
            margin-top: 0;
            color: #f0f9ff;
            font-size: 1.8rem;
            border-bottom: 1px solid #38bdf8;
            padding-bottom: 10px;
        }
        #modal-content p {
            line-height: 1.6;
            margin: 15px 0;
        }
        #modal-content strong {
            color: #7dd3fc;
        }
        #close-modal, #explore-button {
            padding: 10px 8px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            color: #e0f2fe;
            font-size: 24px;
            padding: 0;
        }
        #close-modal:hover {
            color: #ff4d4d;
        }
        #explore-button {
            background-color: #38bdf8;
            color: #0c1a2e;
            display: block;
            width: 100%;
            margin-top: 20px;
            text-align: center;
            text-decoration: none;
        }
        #explore-button:hover {
            background-color: #7dd3fc;
            box-shadow: 0 0 15px rgba(125, 211, 252, 0.7);
        }
        #info-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">TRANSMISSION LOADING...</div>
    </div>

    <div id="info-box">
        Use your mouse to rotate (left-click & drag), pan (right-click & drag), and zoom (scroll).
    </div>

    <div id="modal">
        <div id="modal-content">
            <h2 id="planet-name"></h2>
            <p id="planet-description"></p>
            <p><strong>Major Landmarks:</strong> <span id="planet-landmarks"></span></p>
            <p><strong>Controlling Faction:</strong> <span id="planet-faction"></span></p>
            <p><strong>Status:</strong> <span id="planet-status"></span></p>
            <p><strong>Native Species:</strong> <span id="planet-species"></span></p>
            <a id="explore-button" href="#" target="_blank">Explore Further</a>
        </div>
        <button id="close-modal">&times;</button>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { createNoise2D } from 'https://cdn.skypack.dev/simplex-noise';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 250, 550);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 2000;
        
        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const coreGlow = new THREE.PointLight(0xffeab3, 2, 800);
        coreGlow.position.set(0,0,0);
        scene.add(coreGlow);


        // --- CELESTIAL DATABASE ---
        const planetData = [
            { 
                name: "Coruscant", 
                position: new THREE.Vector3(25, 2, -30), 
                info: { description: "An ecumenopolis, a city-covered planet, that for millennia served as the capital of the Republic and the Empire that followed.", landmarks: "Galactic Senate, Jedi Temple, Imperial Palace", faction: "Galactic Empire / New Republic", status: "Contested", species: "Human, various" },
                design: { noiseScale: 50, terrainHeight: 5, waterLevel: 0, landColor: "#555555", waterColor: "#000000", atmo1Size: 0.03, atmo1Opacity: 0.7, atmo1Color: "#fde047", atmo2Size: 0.1, atmo2Opacity: 0.2, atmo2Color: "#ffffff" },
                sun: { size: 5, color: 0xffff00, distance: 40, speed: 0.001 },
                moons: [ { name: "Centax-1", size: 0.5, color: 0x808080, distance: 8, speed: 0.02 } ]
            },
            { 
                name: "Naboo",
                position: new THREE.Vector3(250, 20, 400),
                info: { description: "A lush, idyllic world known for its peaceful human population and the amphibious Gungans.", landmarks: "Theed Royal Palace, Otoh Gunga", faction: "Galactic Empire (nominal), local resistance", status: "Peaceful", species: "Human, Gungan" },
                design: { noiseScale: 200, terrainHeight: 30, waterLevel: 55, landColor: "#22c55e", waterColor: "#06b6d4", atmo1Size: 0.06, atmo1Opacity: 0.8, atmo1Color: "#67e8f9", atmo2Size: 0.2, atmo2Opacity: 0.3, atmo2Color: "#ffffff" },
                sun: { size: 6, color: 0xfef08a, distance: 50, speed: 0.0009 },
                moons: [
                    { name: "Ohma-D'un", size: 0.7, color: 0x00ced1, distance: 10, speed: 0.018 },
                    { name: "Veruna", size: 0.4, color: 0x9370db, distance: 16, speed: 0.011 }
                ]
            },
            { 
                name: "Tatooine", 
                position: new THREE.Vector3(300, 5, -550), 
                info: { description: "A harsh desert world orbiting two suns. A haven for smugglers and criminals.", landmarks: "Mos Eisley Spaceport, Jabba's Palace, Lars Homestead", faction: "Hutt Cartel", status: "Hostile", species: "Human, Jawa, Tusken Raider" },
                design: { noiseScale: 250, terrainHeight: 15, waterLevel: 5, landColor: "#ca8a04", waterColor: "#facc15", atmo1Size: 0.04, atmo1Opacity: 0.5, atmo1Color: "#fde047", atmo2Size: 0.2, atmo2Opacity: 0.1, atmo2Color: "#fef08a" },
                sun: [
                    { size: 7, color: 0xff4500, separation: 15, speed: 0.002 },
                    { size: 6, color: 0xffd700, separation: 15, speed: 0.002 }
                ],
                planetOrbit: { distance: 60, speed: 0.0007 },
                moons: [ { name: "Ghomrassen", size: 0.4, color: 0xa52a2a, distance: 7, speed: 0.012 }, { name: "Guermessa", size: 0.3, color: 0x8B4513, distance: 11, speed: 0.009 } ]
            },
        ];
        
        const regionData = [
            { name: 'CORE', radius: 60, position: new THREE.Vector3(0, 10, 0) }, 
            { name: 'COLONIES', radius: 120, position: new THREE.Vector3(100, 15, 100) },
            { name: 'INNER RIM', radius: 250, position: new THREE.Vector3(170, -30, -200) }, 
            { name: 'EXPANSION REGION', radius: 320, position: new THREE.Vector3(320, 45, 0) },
            { name: 'MID RIM', radius: 500, position: new THREE.Vector3(400, -60, 300) }, 
            { name: 'OUTER RIM', radius: 750, position: new THREE.Vector3(450, 80, 600) },
            { name: 'UNKNOWN REGIONS', radius: 0, position: new THREE.Vector3(-800, 30, 50) }
        ];

        // --- GALAXY CREATION ---
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        function createStarFlareTexture(colorStr) {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const centerX = size / 2;
            const centerY = size / 2;
            const rgb = hexToRgb(colorStr);
            const haloSize = size / 2;
            const haloOpacity = Math.random() * 0.2 + 0.1;
            const haloGradient = ctx.createRadialGradient(centerX, centerY, haloSize / 4, centerX, centerY, haloSize);
            haloGradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${haloOpacity})`);
            haloGradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
            ctx.fillStyle = haloGradient;
            ctx.fillRect(0, 0, size, size);
            const rayCount = Math.floor(Math.random() * 6) + 4;
            const rayLength = size * 0.4;
            const rayOpacity = Math.random() * 0.2 + 0.1;
            const rayRandomness = Math.random() * 5;
            for (let i = 0; i < rayCount; i++) {
                const angle = (i / rayCount) * Math.PI * 2 + (Math.random() - 0.5) * rayRandomness;
                const length = rayLength * (1 + (Math.random() - 0.5) * rayRandomness);
                const endX = centerX + Math.cos(angle) * length;
                const endY = centerY + Math.sin(angle) * length;
                const rayGradient = ctx.createLinearGradient(centerX, centerY, endX, endY);
                rayGradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${rayOpacity})`);
                rayGradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                ctx.strokeStyle = rayGradient;
                ctx.lineWidth = Math.random() * 1.5 + 0.5;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            const coreSize = size * 0.15;
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, 1)`);
            coreGradient.addColorStop(0.3, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`);
            coreGradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        
        const starColors = [ new THREE.Color("#FFFFFF"), new THREE.Color("#FEF08A"), new THREE.Color("#A5F3FC"), new THREE.Color("#FBCFE8"), new THREE.Color("#FFD8B1") ];
        const whiteStarTexture = createStarFlareTexture("#FFFFFF");
        const galaxyStarVertices = [];
        const galaxyStarColors = [];
        const numGalaxyStars = 40000;
        const galaxyRadius = 800;
        const galaxyArms = 4;
        const armTightness = 0.5;

        for (let i = 0; i < numGalaxyStars; i++) {
            const pos = new THREE.Vector3();
            const angle = (i % (numGalaxyStars / galaxyArms)) / (numGalaxyStars / galaxyArms) * Math.PI * 2;
            const distance = Math.pow(Math.random(), 2) * galaxyRadius;
            const spiral = angle * armTightness;
            const armIndex = Math.floor(i / (numGalaxyStars / galaxyArms));
            const armAngle = (armIndex / galaxyArms) * Math.PI * 2;
            pos.x = Math.cos(angle + spiral + armAngle) * distance;
            const y_bulge = (Math.random() - 0.5) * 120 * Math.pow(1 - distance / galaxyRadius, 2);
            const y_disk = (Math.random() - 0.5) * 20;
            pos.y = y_bulge + y_disk;
            pos.z = Math.sin(angle + spiral + armAngle) * distance;
            galaxyStarVertices.push(pos.x, pos.y, pos.z);
            const color = starColors[Math.floor(Math.random() * starColors.length)];
            galaxyStarColors.push(color.r, color.g, color.b);
        }

        const galaxyGeometry = new THREE.BufferGeometry();
        galaxyGeometry.setAttribute('position', new THREE.Float32BufferAttribute(galaxyStarVertices, 3));
        galaxyGeometry.setAttribute('color', new THREE.Float32BufferAttribute(galaxyStarColors, 3));
        
        const galaxyMaterial = new THREE.PointsMaterial({
            map: whiteStarTexture,
            size: 6,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true,
            vertexColors: true
        });

        const galaxyStarfield = new THREE.Points(galaxyGeometry, galaxyMaterial);
        scene.add(galaxyStarfield);

        const kaminoPosition = new THREE.Vector3(-850, 30, 50);
        const kaminoStarCount = 2000;
        const kaminoInnerRadius = 40;
        const kaminoOuterRadius = 80;
        const kaminoStarVertices = [];
        const kaminoStarColors = [];
        const kaminoColor = new THREE.Color("#A5F3FC");

        for (let i = 0; i < kaminoStarCount; i++) {
            const dist = THREE.MathUtils.randFloat(kaminoInnerRadius, kaminoOuterRadius);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const x = dist * Math.sin(phi) * Math.cos(theta);
            const y = dist * Math.sin(phi) * Math.sin(theta);
            const z = dist * Math.cos(phi);
            kaminoStarVertices.push(x, y, z);
            kaminoStarColors.push(kaminoColor.r, kaminoColor.g, kaminoColor.b);
        }
        
        const kaminoGeometry = new THREE.BufferGeometry();
        kaminoGeometry.setAttribute('position', new THREE.Float32BufferAttribute(kaminoStarVertices, 3));
        kaminoGeometry.setAttribute('color', new THREE.Float32BufferAttribute(kaminoStarColors, 3));
        
        const kaminoMaterial = new THREE.PointsMaterial({
            map: whiteStarTexture,
            size: 4,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true,
            vertexColors: true
        });

        const kaminoCluster = new THREE.Points(kaminoGeometry, kaminoMaterial);
        kaminoCluster.position.copy(kaminoPosition);
        scene.add(kaminoCluster);

        const coreGeometry = new THREE.SphereGeometry(40, 32, 32);
        const coreMaterial = new THREE.MeshBasicMaterial({ color: 0xffeab3, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(core);
        
        const regionLabels = [];
        
        regionData.forEach(region => {
            if (region.radius > 0) {
                const geometry = new THREE.RingGeometry(region.radius - 1, region.radius, 128);
                const material = new THREE.MeshBasicMaterial({ color: 0xffc107, side: THREE.DoubleSide, transparent: true, opacity: 0.4 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = Math.PI / 2;
                scene.add(mesh);
            }
            
            const text = document.createElement('div');
            text.className = 'region-label';
            text.textContent = region.name;
            const label = new CSS2DObject(text);
            label.position.copy(region.position);
            scene.add(label);
            regionLabels.push(label);
        });

        const planetMeshes = [];
        const noise2D = createNoise2D();

        const atmoVertexShader = `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const atmoFragmentShader = `
            uniform vec3 uColor;
            uniform float uOpacity;
            uniform float uPower;
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), uPower);
                gl_FragColor = vec4(uColor, 1.0) * intensity * uOpacity;
            }
        `;

        function generatePlanetTexture(design) {
            const { noiseScale, terrainHeight, waterLevel, landColor, waterColor } = design;
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 1024;
            textureCanvas.height = 512;
            const ctx = textureCanvas.getContext('2d');
            const width = textureCanvas.width;
            const height = textureCanvas.height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const noiseVal = (noise2D(x / noiseScale, y / noiseScale) + 1) / 2; 
                    const normalizedHeight = noiseVal * 100;
                    if (normalizedHeight < waterLevel) {
                        ctx.fillStyle = waterColor;
                    } else if (normalizedHeight < waterLevel + terrainHeight) {
                        const landShade = Math.floor(100 + (normalizedHeight - waterLevel) / terrainHeight * 100);
                        const r = parseInt(landColor.substr(1, 2), 16);
                        const g = parseInt(landColor.substr(3, 2), 16);
                        const b = parseInt(landColor.substr(5, 2), 16);
                        ctx.fillStyle = `rgb(${r*landShade/200}, ${g*landShade/200}, ${b*landShade/200})`;
                    } else {
                        ctx.fillStyle = landColor;
                    }
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            return new THREE.CanvasTexture(textureCanvas);
        }

        function createProceduralPlanet(data) {
            const planetGroup = new THREE.Group();
            const planetGeometry = new THREE.SphereGeometry(3, 32, 32);
            const planetTexture = generatePlanetTexture(data.design);
            const planetMaterial = new THREE.MeshPhongMaterial({ map: planetTexture });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.userData = data;
            planetGroup.add(planetMesh);
            const atmo1Material = new THREE.ShaderMaterial({
                vertexShader: atmoVertexShader,
                fragmentShader: atmoFragmentShader,
                uniforms: {
                    uColor: { value: new THREE.Color(data.design.atmo1Color) },
                    uOpacity: { value: data.design.atmo1Opacity },
                    uPower: { value: 2.0 }
                },
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            const atmo1 = new THREE.Mesh(planetGeometry, atmo1Material);
            atmo1.scale.set(1.0 + data.design.atmo1Size, 1.0 + data.design.atmo1Size, 1.0 + data.design.atmo1Size);
            planetGroup.add(atmo1);
            const atmo2Material = atmo1Material.clone();
            atmo2Material.uniforms.uColor.value = new THREE.Color(data.design.atmo2Color);
            atmo2Material.uniforms.uOpacity.value = data.design.atmo2Opacity;
            atmo2Material.uniforms.uPower.value = 4.0;
            const atmo2 = new THREE.Mesh(planetGeometry, atmo2Material);
            atmo2.scale.set(1.0 + data.design.atmo2Size, 1.0 + data.design.atmo2Size, 1.0 + data.design.atmo2Size);
            planetGroup.add(atmo2);
            return planetGroup;
        }

        const orbitalSystems = [];
        planetData.forEach(p => {
            const solarSystemGroup = new THREE.Object3D();
            solarSystemGroup.position.copy(p.position);
            scene.add(solarSystemGroup);

            const planetGroup = createProceduralPlanet(p);
            
            const system = {
                systemGroup: solarSystemGroup,
                planetGroup: planetGroup,
                moons: [],
                planetRotationSpeed: 0.005,
                angle: Math.random() * Math.PI * 2
            };

            if (Array.isArray(p.sun)) { // Binary sun system
                system.binaryPivot = new THREE.Object3D();
                solarSystemGroup.add(system.binaryPivot);
                
                const sun1 = new THREE.Mesh(new THREE.SphereGeometry(p.sun[0].size, 32, 32), new THREE.MeshBasicMaterial({ color: p.sun[0].color }));
                sun1.position.x = p.sun[0].separation / 2;
                
                const sun2 = new THREE.Mesh(new THREE.SphereGeometry(p.sun[1].size, 32, 32), new THREE.MeshBasicMaterial({ color: p.sun[1].color }));
                sun2.position.x = -p.sun[1].separation / 2;

                system.binaryPivot.add(sun1);
                system.binaryPivot.add(sun2);
                system.binarySpeed = p.sun[0].speed;
                
                solarSystemGroup.add(planetGroup);
                system.planetOrbitSpeed = p.planetOrbit.speed;
                system.planetOrbitDistance = p.planetOrbit.distance;

            } else { // Single sun
                const sun = new THREE.Mesh(new THREE.SphereGeometry(p.sun.size, 32, 32), new THREE.MeshBasicMaterial({ color: p.sun.color }));
                solarSystemGroup.add(sun);
                solarSystemGroup.add(planetGroup);
                system.planetOrbitSpeed = p.sun.speed;
                system.planetOrbitDistance = p.sun.distance;
            }
            
            planetMeshes.push(planetGroup.children[0]);

            p.moons.forEach(m => {
                const moonGeometry = new THREE.SphereGeometry(m.size, 16, 16);
                const moonMaterial = new THREE.MeshStandardMaterial({ color: m.color });
                const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
                planetGroup.add(moonMesh);
                system.moons.push({ mesh: moonMesh, speed: m.speed, distance: m.distance, angle: Math.random() * Math.PI * 2 });
            });
            
            orbitalSystems.push(system);

            const text = document.createElement('div');
            text.className = 'label';
            text.textContent = p.name;
            const label = new CSS2DObject(text);
            planetGroup.add(label);
            label.position.y = 8;
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetMeshes, true);
            if (intersects.length > 0) {
                const clickedPlanetData = intersects[0].object.userData;
                showModal(clickedPlanetData);
            }
        }
        
        window.addEventListener('click', onMouseClick);
        
        const modal = document.getElementById('modal');
        const closeModalButton = document.getElementById('close-modal');

        function showModal(data) {
            document.getElementById('planet-name').textContent = data.name;
            document.getElementById('planet-description').textContent = data.info.description;
            document.getElementById('planet-landmarks').textContent = data.info.landmarks;
            document.getElementById('planet-faction').textContent = data.info.faction;
            document.getElementById('planet-status').textContent = data.info.status;
            document.getElementById('planet-species').textContent = data.info.species;
            const exploreButton = document.getElementById('explore-button');
            const planetNameNoSpaces = data.name.replace(/[\s']/g, '');
            exploreButton.href = `#`; // Placeholder link
            modal.style.display = 'block';
        }

        function hideModal() {
            modal.style.display = 'none';
        }

        closeModalButton.addEventListener('click', hideModal);
        window.addEventListener('click', (event) => {
            if (event.target === modal) { hideModal(); }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();
            scene.rotation.y += 0.00005;

            orbitalSystems.forEach(sys => {
                sys.angle += sys.planetOrbitSpeed;
                sys.planetGroup.position.x = Math.cos(sys.angle) * sys.planetOrbitDistance;
                sys.planetGroup.position.z = Math.sin(sys.angle) * sys.planetOrbitDistance;
                sys.planetGroup.rotation.y += sys.planetRotationSpeed;

                if(sys.binaryPivot){
                    sys.binaryPivot.rotation.y += sys.binarySpeed;
                }

                sys.moons.forEach(moonData => {
                    moonData.angle += moonData.speed;
                    moonData.mesh.position.x = Math.cos(moonData.angle) * moonData.distance;
                    moonData.mesh.position.z = Math.sin(moonData.angle) * moonData.distance;
                });
            });

            const cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition);

            regionLabels.forEach(label => {
                const labelPosition = new THREE.Vector3();
                label.getWorldPosition(labelPosition);
                const distance = cameraPosition.distanceTo(labelPosition);
                const baseSize = 20;
                const scaleFactor = 3000;
                let newSize = baseSize * (scaleFactor / distance);
                newSize = Math.max(8, Math.min(newSize, 30)); 
                label.element.style.fontSize = `${newSize}px`;
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
                
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = () => {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 1000); 
            animate();
        };
    </script>
</body>
</html>

